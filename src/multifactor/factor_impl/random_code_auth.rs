use std::{future::Future, sync::Arc, time::SystemTime};

use actix_session::{Session, SessionExt};
use actix_web::HttpRequest;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::multifactor::factor::{CheckCodeError, Factor, GenerateCodeError};

/// ID to reference random code mfa
pub const MFA_ID_RANDOM_CODE: &str = "RNDCODE";

const MFA_RANDOM_CODE_KEY: &str = "mfa_random_code";

/// Interface for sending the code to the user
#[async_trait]
pub trait CodeSender {
    async fn send_code(&self, random_code: RandomCode) -> Result<(), CodeSendError>;
}

#[derive(Error, Debug)]
#[error("Sending random code failed: {msg}")]
pub struct CodeSendError {
    msg: String,
}

impl CodeSendError {
    #[allow(unused)]
    fn new(msg: &str) -> Self {
        Self {
            msg: msg.to_owned(),
        }
    }
}

impl Default for CodeSendError {
    fn default() -> Self {
        Self {
            msg: "Cannot send code".to_owned(),
        }
    }
}

/// The code and its validity generated by [MfaRandomCode]
#[derive(Deserialize, Serialize, Clone)]
pub struct RandomCode {
    value: String,
    valid_until: SystemTime,
}

impl RandomCode {
    pub fn new(value: &str, valid_until: SystemTime) -> Self {
        Self {
            value: value.to_owned(),
            valid_until,
        }
    }

    pub fn value(&self) -> &str {
        &self.value
    }

    pub fn valid_until(&self) -> &SystemTime {
        &self.valid_until
    }
}

/// Random code implementation of [Factor] 
/// *Currently it works only with session based authentication.*
///
/// Takes in a function that should generate a random code and [CodeSender]
/// The generated code is then saved in the Session.
pub struct MfaRandomCodeFactor<T> {
    code_generator: fn() -> RandomCode,
    code_sender: Arc<T>,
}

impl<T: CodeSender> MfaRandomCodeFactor<T> {
    pub fn new(code_generator: fn() -> RandomCode, code_sender: Arc<T>) -> Self {
        Self {
            code_generator,
            code_sender,
        }
    }
}

impl MfaRandomCodeFactor<()> {
    pub fn id() -> String {
        MFA_ID_RANDOM_CODE.to_owned()
    }
}

impl<T: CodeSender> Factor for MfaRandomCodeFactor<T>
where
    T: CodeSender + 'static,
{
    fn generate_code(
        &self,
        req: &HttpRequest,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<(), GenerateCodeError>>>> {
        let random_code = (self.code_generator)();
        let session = req.get_session();
        let sender = Arc::clone(&self.code_sender);

        Box::pin(async move {
            session
                .insert(MFA_RANDOM_CODE_KEY, random_code.clone())
                .map_err(|e| {
                    purge_session_and_error(&session, "Could not insert mfa code into session", e)
                })?;

            sender
                .send_code(random_code)
                .await
                .map_err(|e| purge_session_and_error(&session, "Could not send code to user", e))?;

            Ok(())
        })
    }

    fn unique_id(&self) -> String {
        MFA_ID_RANDOM_CODE.to_owned()
    }

    fn check_code(
        &self,
        code: &str,
        req: &HttpRequest,
    ) -> std::pin::Pin<Box<dyn Future<Output = Result<(), CheckCodeError>>>> {
        let session = req.get_session();
        let owned_code = code.trim().to_owned();

        Box::pin(async move {
            let random_code = session
                .get::<RandomCode>(MFA_RANDOM_CODE_KEY)
                .map_err(|_| {
                    purge_session_and_unknown_code_error(
                        &session,
                        "Could not load random code from session",
                    )
                })?;

            if let Some(random_code) = random_code {
                let now = SystemTime::now();
                if &now >= random_code.valid_until() {
                    return Err(cleanup_and_time_is_up_error(&session));
                }

                if owned_code != random_code.value() {
                    // ToDo: here we need to cound the attempts and reject finally with cleanup
                    return Err(CheckCodeError::InvalidCode);
                }

                Ok(())
            } else {
                Err(purge_session_and_unknown_code_error(
                    &session,
                    "No random code in session",
                ))
            }
        })
    }
}

fn purge_session_and_error(
    session: &Session,
    msg: &str,
    e: impl std::error::Error + 'static,
) -> GenerateCodeError {
    session.purge();
    GenerateCodeError::new_with_cause(msg, e)
}

fn purge_session_and_unknown_code_error(session: &Session, msg: &str) -> CheckCodeError {
    session.purge();
    CheckCodeError::UnknownError(msg.to_owned())
}
fn cleanup_and_time_is_up_error(session: &Session) -> CheckCodeError {
    session.purge();
    CheckCodeError::TimeIsUp("Code is no longer valid".to_owned())
}

#[cfg(test)]
mod tests {
    use crate::multifactor::factor_impl::random_code_auth::{MfaRandomCodeFactor, MFA_ID_RANDOM_CODE};

    #[test]
    fn test_static_id() {
        assert_eq!(MfaRandomCodeFactor::id(), MFA_ID_RANDOM_CODE);
    }
}
